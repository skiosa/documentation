% !TeX root = ../dokumentation.tex

\chapter{Technische Umsetzung}


\section{Architektur}
Um unsere Plattform potenziellen Nutzern zugänglich zu machen und bestimmte Teile unseres Workflows\footnote{Arbeitsablauf} zu Automatisieren, hosten wir unsere Architektur in einer Cloud Umgebung.
Dabei läuft unsere Architektur auf der Kontainer Orchestrierungs Plattform Kubernetes, für welches wir die leichgewichtige (und leichter zu verwaltende) Variante \textit{k3s}~\parencite{web/k3s} verwenden.
Auf diesem Kubernetes System werden \ac{CI/CD} Plattformen gehosted und unsere Applikation sowie deren Abhängigkeiten. Dadruch sind wir nicht an öffentlich-kostenfreie System limitiert und können unsere
System perfekt auf unseren Workflow und die Applikation anpassen.

\subsection{Übersicht der Services}
Unser Produkt ist in mehrere Services aufgeteilt. Die Services sind \textit{Core-Service}, \textit{Polling-Service} und das \textit{Frontend}.
Desweiteren gibt es eine \textit{PostgreSQL Datenbank} und eine \textit{Keycloak} Instanz. Die letzten beiden Services sind Abhänigkeiten von unseren entwickelten Services.
Die Datenbank wird dafür verwendet um Daten wie RSS-Feeds und Artikel zu speichern.
Keycloak wird dafür verwendet um den \textit{Core-Service} und das \textit{Frontend} abzusichern und die Benutzer zu verwalten.
Die Hauptaufgabe des \textit{Core-Services} ist es RSS-Feeds und Artikel zur Verfügung zu stellen, dies geschieht mittels \textit{GraphQL}. Desweiteren bietet er die Möglichkeit
RSS-Feeds anzulegen und Abonnents, Favouriten und Lesezeichen eines Benutzers zu verwalten.
Der \textit{Polling-Service} ist für die automatische Datenabfrage von RSS-Feeds und deren Artikel zuständig. Diese werden anschließend in der Datenbank gespeichert.
Das \textit{Frontend} ist die Endschnittstelle unseres Produkts zu dem Benutzer.
Es wird dafür verwendet um die Daten des \textit{Core-Services} dem Benutzer zugänglich zu machen.
Das folgenden Diagramm veranschautlicht die Skiosa Service-Architektur. Die Sevices mit den gestrichelten Linien sind die Abhängigkeiten.
\begin{figure}[!htbp]
    \centering    
    \usetikzlibrary{positioning}
    \begin{tikzpicture}
        \matrix [column sep=7mm, row sep=5mm] {
            \node (database) [draw, shape=rectangle, dashed] {Datenbank}; &&
            \node (polling_service) [draw, shape=rectangle] {Polling - Service}; \\
            \node (core_service) [draw, shape=rectangle] {Core - Service}; &
            \node (frontend) [draw, shape=rectangle] {Frontend}; \\
            \node (keycloak) [draw, shape=rectangle, dashed] {Keycloak}; \\
            };
            \draw[->, thick] (core_service) -- (database);
            \draw[->, thick] (frontend) -- (core_service);
            \draw[->, thick] (polling_service) -- (database);
            \draw[->, thick] (core_service) -- (keycloak);
            \draw[->, thick] (frontend) -- (keycloak);
        \end{tikzpicture}        
\caption{Diagramm – Darstellung der Service Architektur}
\end{figure}

\subsection{CI/CD Infrastrukture}
Um Code Qualität zu gewährleisten, wurde eine \ac{CI/CD} Infrastruktur entwickelt.
Diese ermöglicht es uns automatisiert Tests wie Unit und Integration Tests auszuführen und nach jeder Änderung aktuelle Versionen der Software zu veröffentlichen.
Da zum Beispiel eine neue veröffentlichung bei Änderungen auf der Master Branch stattfinden sollen, gibt es drei verschieden \ac{CI/CD} Pipelines.
Eine die nur Unit-Tests ausführt, eine die komplexe Tests ausführt und eine die eine neue Version veröffentlicht.

\subsubsection{Übersicht der Standard \ac{CI}-Pipline}
Die Standard \ac{CI}-Pipeline wird bei jedem Commit der nicht auf dem Master Branch stattfindet ausgeführt. Dabei hat die Standard Pipeline den geringsten Umfang and Aufgaben.
Diese führt nur die Unit-Tests aus, dazu muss der Code gecloned und alle Dependencies installiert werden. Somit sind direkt Fehler schon früh erkennbar, wenn diese Pipeline fehlschlägt.
\begin{figure}[!htbp]
    \centering    
    \usetikzlibrary{positioning}
    \begin{tikzpicture}
        \matrix [column sep=7mm, row sep=5mm] {
            \node (clone) [draw, shape=rectangle] {Clone Code}; &&
            \node (npm_setup) [draw, shape=rectangle] {Install Dependencies}; &&
            \node (unit_test) [draw, shape=rectangle] {Unit-Tests}; &&
            \node (sonar) [draw, shape=rectangle] {Code-Analyse}; \\
            };
            \draw[->, thick] (clone) -- (npm_setup);
            \draw[->, thick] (npm_setup) -- (unit_test);
            \draw[->, thick] (unit_test) -- (sonar);
        \end{tikzpicture}        
\caption{Diagramm – Darstellung der Standard \ac{CI}-Pipeline}
\end{figure}

\subsubsection{Übersicht der Pull-Request \ac{CI}-Pipline}
Die Pull-Request \ac{CI}-Pipeline wird ausgeführt sobald ein Pull-Request erstellt wird. Ihr Ziel ist es den jeweiligen Reviewer zu unterstützen, indem sie Tests und Code-Analyse durchführt.
Die Ergebnisse der Code Analyse werden direkt auf der Pull-Request Seite dargestellt. Sollten diese nicht den mindestanforderungen entsprechen, wird der Pull-Request dadurch blockiert.
Die Pipeline beinhaltet die selben Schritte wie die Standard Pipeline, sie erweitert diese lediglich um Integration-Tests.
\begin{figure}[!htbp]
    \centering    
    \usetikzlibrary{positioning}
    \begin{tikzpicture}
        \matrix [column sep=7mm, row sep=10mm] {
            \node (clone) [draw, shape=rectangle] {Clone Code}; &&
            \node (database) [draw, shape=rectangle] {Start \ac{CI}-Database}; &&
            \node (npm_setup) [draw, shape=rectangle] {Install Dependencies}; \\
            \node (unit_test) [draw, shape=rectangle] {Unit-Tests}; &&
            \node (init_db) [draw, shape=rectangle] {Initialize Database}; &&
            \node (start_app) [draw, shape=rectangle] {Start Application}; \\
            \node (int_test) [draw, shape=rectangle] {Integration-Tests}; &&
            \node (sonar) [draw, shape=rectangle] {Code-Analyse}; \\
            };
            \draw[->, thick] (clone) -- (database);
            \draw[->, thick] (database) -- (npm_setup);
            \draw[->, thick] (npm_setup) -- (unit_test);
            \draw[->, thick] (unit_test) -- (init_db);
            \draw[->, thick] (init_db) -- (start_app);
            \draw[->, thick] (start_app) -- (int_test);
            \draw[->, thick] (int_test) -- (sonar);
        \end{tikzpicture}
\caption{Diagramm – Darstellung der Pull-Request \ac{CI}-Pipeline}
\end{figure}

\subsubsection{Übersicht der Master \ac{CI}-Pipline}
Die Master \ac{CI}-Pipeline wird bei einen Commit auf den Master Branch ausgeführt. Dabei hat die Pipeline die Aufgabe den neuen Code auszurollen und sommit live zu bringen.
Zur Sicherheit werden auch wieder die Unit-Tests ausgeführt, damit auch wirklich sichergestellt wird, dass der Code lauffähig ist. Anschließend wird ein neues Docker-Image gebaut
welches dann in der Docker-Registry gespeichert wird. Nach erfolgreichem bauen des Images, wird die neue Image-Version in das Kubernetes-Depyoment geschrieben. Denn ArgoCD~\parencite{web/argocd} unser \ac{CD} Tool
erkennt automatisch Änderungen an den Kubernetes-Deployments und übernimmt diese. Somit sind die Code Änderungen an der Software in wenigen Minuten live ausgerollt.
\begin{figure}[!htbp]
    \centering    
    \usetikzlibrary{positioning}
    \begin{tikzpicture}
        \matrix [column sep=7mm, row sep=10mm] {
            \node (clone) [draw, shape=rectangle] {Clone Code}; &&
            \node (npm_setup) [draw, shape=rectangle] {Install Dependencies}; &&
            \node (unit_test) [draw, shape=rectangle] {Unit-Tests}; \\
            \node (docker_build) [draw, shape=rectangle] {Build Docker Image}; &&
            \node (trigger_cd) [draw, shape=rectangle] {Trigger \ac{CD}}; &&
            \node (sonar) [draw, shape=rectangle] {Code-Analyse}; \\
            };
            \draw[->, thick] (clone) -- (npm_setup);
            \draw[->, thick] (npm_setup) -- (unit_test);
            \draw[->, thick] (unit_test) -- (docker_build);
            \draw[->, thick] (docker_build) -- (trigger_cd);
            \draw[->, thick] (trigger_cd) -- (sonar);
        \end{tikzpicture}
\caption{Diagramm – Darstellung der Master \ac{CI}-Pipeline}
\end{figure}

\section{Mockups}
\subsection{Design Language}
Eine Design-Language kann als Framework verstanden werden, das es Teams ermöglicht, 
zusammenhängende Schnittstellen zu erstellen und zu entwerfen um Anwendungen ein "einzigartiges Gefühl" zu verleihen.
Im engeren Sinne kann eine Design-Language als Set von Regeln, die Typografie, Formen und Muster vorschreiben.

Zur Maximierung der Vorteile eines solchen Systems in unserem Projekt wurden folgende Ziele und Ideen genutzt:
\begin{itemize}
    \item Give a coherent feel to Skiosa, staying in line with branding and thus improving the perceived value of our project.
    \item Visually sperate differet levels of interest (ex. content, settings, navigation)
    \item Clearly indicate which parts of the UI are ours VS. which parts are from external sources for legal reasons.
\end{itemize}

Folgende Schriftarten sollen verwendet werden. 

\begin{itemize}
    \item Primary Titles (such as “Login” on the login page): Pacifico
    \item Helper Text (menu items, buttons, subtitles, etc): Ubuntu Mono in Bold
\end{itemize}


In SKIOSA gibt es drei Arten von Content.  
\begin{itemize}
    \item Side bar (split top bar on mobile) with important content
    \item Main Content
    \item Meta Content
\end{itemize}

Damit Nutzer Content besser unterscheiden zu können, wird das Design dieser drei Items unterschiedlich sein.

\textbf{Side bar:}
\begin{itemize}
    \item Darker (or inverse) coloration to make it stand out
    \item Separation of Navigational and Interactional content (ex. liking an article vs. going to your subscriptions) will be indicated by filled shapes vs. wireframed shapes (vgl. Abbildung~\ref{fig:Sidebar-Design-Shema})
    \item Skiosa Logo will always be displayed at top
\end{itemize}

\begin{figure}
    \includegraphics[width=\linewidth]{Sidebar-Design-Sheme.png}
    \caption{Example for Separation of Navigational and International content (red: Interactional, green: navigational)}
    \label{fig:Sidebar-Design-Shema}
\end{figure}

\textbf{Main Content}
\begin{itemize}
    \item Consists of separate cards on darker background, without shadows
    \item Single cards contain optional “subtitles” to explain their Point
    \item If a page has a header, that header, along with a description or other meta data will make up the top tile (exceptions are single tile pages)
    \item Content is always the most colorful element of the page, switching between different tones for different items (vgl. Abbildung~\ref{fig:Page-Structure-Example})
\end{itemize}

\begin{figure}
    \includegraphics[width=\linewidth]{Page-Structure.png}
    \caption{Example for page structure (red: subtitle, green: card)}
    \label{fig:Page-Structure-Example}
\end{figure}

\textbf{Meta Content}
\begin{itemize}
    \item Always single card pages
    \item Differentiated  to regular pages by being a softened version of the side bar
    \item Use of multiple colors (as with feed above) should generally be avoided here
\end{itemize}
 
\textbf{Formen}

Im Allgemeinen sollen Formen abgerundete Rechtecke mit einem Radius von 20 sein. Die Sidebar ist hier die Außnahme, da sie richtige Ecken hat, 
mit dem Ziel diese bewusst visuell vom restlichen Content abzugrenzen.
Buttons, Input-Felder, etc. sollen wie in Abbildung~\ref{fig:Design-Shapes-Example} aussehen. 
Dabei müssen Felder, die über mehrere Lines gehen, wie bspw. Listen, diese Regel nicht befolgen.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{Design-Shapes-Example.png}
    \caption{Beispiel für Form von Buttons und Input-Feldern}
    \label{fig:Design-Shapes-Example}
\end{figure}

Bei der Angabe von Feldern, die andernfalls Inhalte oder Benutzerprofilbilder enthalten würden,
sollten wir allgemeine Symbole verwenden, die sich auf ihre Kategorie beziehen, um diese Lücke zu schließen.

\textbf{Farbschema}

In Skiosa wurde ein Farbschema festgelegt mit dem Ziel, 
eine möglichst einheitliche Nutzererfahrung zu ermöglichen. 
Dabei wird zwischen einem Dark-Mode und einem Light-Mode unterschieden (vgl. Abbildung~\ref{fig:Vergleich-light-dark}).
Für beide Modi wurden die Farben von Hintergründen und Artikelschriftart festgelegt.
Der Light- und Dark-Modus verwendet 
aber bei sonstigen Schriftfarben, Buttons, Eingabefeldern und Navigationshintergründen die selben Farben.

\begin{figure}[h]
    \includegraphics[width=\linewidth]{Vergleich-zwischen-light-und-dark-theme.png}
    \caption{Vergleich zwischen Light- und Dark-Modus in Skiosa}
    \label{fig:Vergleich-light-dark}
\end{figure}

\subsection{Nutzung von Figma}

Zur Erstellung des Designs und der Mockups wurde in Skiosa das Tool Figma verwendet. 
Für Komponenten die häufig verwendet werden sollen (bpsw. Buttons oder Farben) wurden sogenannte Common-Components erstellt.
Diese können bei der Erstellung von neuen Seiten wieder verwendet werden. 
Dadurch bleibt ein Button immer gleich und wird auch nur einmal in einem Angular-Component umgesetzt werden.
Ähnlich werden auch die Farben umgesetzt. 
Ziel ist es, effizienter neue Seiten erstellen zu können, die in das Design passen. 

\section{Technische Änderungen zur anfänglichen Struktur} \label{tech_changes}
Im Laufe unseres Projektes sind einige technischen Hürden entstanden. Diese haben zum Teil dazu geführt das unsere ursprünglichen Requirements nicht mehr erfüllt werden konnten.
Deshalb wurden sie im Nachhinein dementsprechend leicht angepasst.

\begin{table}[h]
    \resizebox{\textwidth}{!}{\begin{tabular}{|p{8cm}|p{8cm}|}
    \hline
    Beschreibung der Änderung & Begründung der Änderung\\ \hline
    In der Plattform soll von RSS Feeds kein Inhalt (bzw. nur eine Beschreibung) angezeigt werden & Ein Großteil der im Internet vohandenen RSS Feeds verlinken nur auf Artikel und enthalten keinen Inhalt. \\ 
    Das Hinzufügen von Feeds aus der Creator Page wurde zu einem Must-Have Requirement & Das anfänglich geplante manuelle Einbinden von Feeds ist als zu zeitaufwändig eingeschätzt worden. \\
    Polling Intervall (TTL) nicht mehr Teil der Creator Page & Ein RSS Feed besitzt bereits ein TTL Feld, durch das dieser Interval bereits angegeben wird. \\
    \hline
\end{tabular}}
\caption{Tabelle – Änderungen zur anfänglichen Struktur}
\end{table}

Wie am Beispiel des RSS Feeds der Tagesschau\footnote{https://www.tagesschau.de/xml/rss2/} zu erkennen ist, liefern viele RSS Feeds einen TTL Wert.
Mit diesem ist zu erkennen, in welchem Intervall der jeweilige Feed neue Informationen bereitstellt. Das mögliches Polling Intervall in der Content-Creator-Page (falls implementiert) wird dadurch redundant.
Zusätzlich ist am obersten Artikel zu sehen, wie im Inhalt nur auf ein Link zur Webseite der Tagesschau verwiesen wird und nicht etwa der Inhalt des Artikels enthalten ist.
So ist es ebenfalls leicht zu erkennen, dass das Anzeigen des Inhalts, wie es in den initialen Requirements enthalten ist, nicht möglich ist.

\begin{lstlisting}[title=Tagesschau RSS Feed,language=xml]
<rss version="2.0">
    <channel>
        <title>tagesschau.de - Die Nachrichten der ARD</title>
        <link>https://www.tagesschau.de</link>
        <description>tagesschau.de</description>
        <language>de</language>
        <copyright>ARD-aktuell / tagesschau.de</copyright>
        <lastBuildDate>Tue, 03 May 2022 16:54:20 +0200</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <ttl>10</ttl>
        <item>
            <title>Marktbericht: Anleger wagen sich noch etwas vor</title>
            <link>
            https://www.tagesschau.de/wirtschaft/finanzen/marktberichte/boerse-marktbericht-dax-dow-jones-101.html
            </link>
            <pubDate>Tue, 03 May 2022 18:10:20 +0200</pubDate>
            <description>
            Nach meist richtungslosem Handel kam am Ende des Tages doch noch etwas Interesse auf. Die Anleger warten derweil mit Spannung auf die Ergebnisse der Zinssitzung der US-Notenbank.
            </description>
            <guid>
            https://www.tagesschau.de/wirtschaft/finanzen/marktberichte/boerse-marktbericht-dax-dow-jones-101.html
            </guid>
            <content:encoded>
            <p> <a href="https://www.tagesschau.de/wirtschaft/finanzen/marktberichte/boerse-marktbericht-dax-dow-jones-101.html"><img src="https://www.tagesschau.de/multimedia/bilder/boerse-frankfurt-141~_v-mittel16x9.jpg"/></a> <br/> <br/> Nach meist richtungslosem Handel kam am Ende des Tages doch noch etwas Interesse auf. Die Anleger warten derweil mit Spannung auf die Ergebnisse der Zinssitzung der US-Notenbank. <a href="https://www.tagesschau.de/wirtschaft/finanzen/marktberichte/boerse-marktbericht-dax-dow-jones-101.html">mehr</a> </p> <ul> </ul> </p> <p><a href="https://www.tagesschau.de/wirtschaft/finanzen/marktberichte/boerse-marktbericht-dax-dow-jones-101.html">Meldung bei www.tagesschau.de lesen</a></p>
            </content:encoded>
        </item>
    </channel>
</rss>
\end{lstlisting}
